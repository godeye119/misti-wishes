# Feature development workflow

---

## Workflow Steps

### [x] Step: Requirements

Your job is to generate a Product Requirements Document based on the feature description,

First, analyze the provided feature definition and determine unclear aspects. For unclear aspects: - Make informed guesses based on context and industry standards - Only mark with [NEEDS CLARIFICATION: specific question] if: - The choice significantly impacts feature scope or user experience - Multiple reasonable interpretations exist with different implications - No reasonable default exists - Prioritize clarifications by impact: scope > security/privacy > user experience > technical details

Ask up to 5 most priority clarifications to the user. Then, create the document following this template:

```
# Feature Specification: [FEATURE NAME]


## User Stories*


### User Story 1 - [Brief Title]

**Acceptance Scenarios**:

1. **Given** [initial state], **When** [action], **Then** [expected outcome]
2. **Given** [initial state], **When** [action], **Then** [expected outcome]

---

## Requirements*

## Success Criteria*

```

Save the PRD into `c:\Users\ashvi\OneDrive\Desktop\lantern\.zencoder\chats\1062a1a8-fab7-4459-97b0-37ef4c81d8d0/requirements.md`.

### [x] Step: Technical Specification

Based on the PRD in `c:\Users\ashvi\OneDrive\Desktop\lantern\.zencoder\chats\1062a1a8-fab7-4459-97b0-37ef4c81d8d0/requirements.md`, create a detailed technical specification to be used by a coding agent to implement the feature. Follow this template:

```
# Technical Specification: [FEATURE]

## Technical Context
Language/Version, primary dependencies, etc

## Technical Implementation Brief

Summarize key technical decisions for implementing the feature. Make sure they take into account the existing code as much as possible.

## Source Code Structure

## Contracts

Define addition or changes in data models, DB schemas, APIs, code interfaces etc

## Delivery Phases

Define several incremental deliverables for the feature. Each should be a minimal viable product testable end-to-end.

## Verification Strategy

Define how the coding agent can verify each deliverable it creates. Provide instructions for the agent to perform the verification using available tools (lint/test commands, bash commands) and create helper scripts and tools for more complex result verification.
The verification for each deliverable should be executable by a coding agent using built-in capabilities (lint and test commands from the project, bash commands), pre-generated helper scripts or MCP servers. Research and add to the spec:

- MCP servers that should be installed to help the agent with the verification

- helper scripts that need to be generated in the first phases of the plan to verify complex scenarios that can't be covered by the tests in the project's test framework(s)

- any sample input artifact(s) that are required for verification. Note if these artifacts can be a) generated by the agent; b) discovered by the agent on line; c) must be provided by the user.
```

Save the spec to `c:\Users\ashvi\OneDrive\Desktop\lantern\.zencoder\chats\1062a1a8-fab7-4459-97b0-37ef4c81d8d0/spec.md`.

### [x] Step: Implementation Plan

Based on the technical spec in `c:\Users\ashvi\OneDrive\Desktop\lantern\.zencoder\chats\1062a1a8-fab7-4459-97b0-37ef4c81d8d0/spec.md`, create a detailed task plan and update `c:\Users\ashvi\OneDrive\Desktop\lantern\.zencoder\chats\1062a1a8-fab7-4459-97b0-37ef4c81d8d0/plan.md`. Each task should have task definition, references to contracts to be used/implemented, deliverable definition and verification instructions.

Format each task as

```
### [ ] Step: <task_name>
Task instructions
```

---

## Implementation Tasks

### [x] Step: Phase 1 - Project Setup & Basic Structure

**Task Definition**:
Initialize a Vite React project with all necessary dependencies and create the foundational component structure with a full-screen night sky gradient background.

**Contracts to Implement**:
- Component: `SkyLanternApp` (basic shell, no props)
- CSS Module: `SkyLanternApp.module.css` with `.container` class

**Tasks**:
1. Run `npm create vite@latest . -- --template react` to initialize Vite React project
2. Install dependencies: `npm install @react-spring/web`
3. Create `src/SkyLanternApp.jsx` with basic functional component structure
4. Create `src/SkyLanternApp.module.css` with:
   - `.container` class: full-screen (100vw, 100vh), deep night gradient background (midnight blue #0a1128 → dark purple #1a0a3e)
5. Update `src/main.jsx` to render `SkyLanternApp` component
6. Update `index.html` with appropriate title and meta tags

**Deliverable**: 
React app that displays a full-screen night sky gradient background when accessed in browser.

**Verification**:
- Run `npm install` to install dependencies
- Run `npm run dev` to start development server
- Open browser to `http://localhost:5173`
- Verify:
  - [ ] Dev server starts without errors
  - [ ] Browser shows full-screen gradient background (midnight blue to dark purple)
  - [ ] No console errors in browser DevTools

---

### [x] Step: Phase 2 - Atmospheric Background & Stars

**Task Definition**:
Add dynamic atmospheric elements to the night sky including subtle animated stars and faint nebula clouds to create an immersive environment.

**Contracts to Implement**:
- CSS Module classes: `.backgroundStars`, `.star`, `.nebula`
- Optional: React state for star positions if using react-spring

**Tasks**:
1. In `SkyLanternApp.module.css`, create animated stars:
   - Use CSS `@keyframes` for slow twinkling and subtle movement
   - Create multiple star sizes using different classes
2. Add faint nebula clouds using radial gradients with low opacity
3. In `SkyLanternApp.jsx`, generate 30-50 star elements with random positions
4. Apply CSS animations to stars for slow drift and twinkle effect
5. Ensure background elements are behind all other content (z-index)
6. Add responsive behavior (stars scale/reposition on resize)

**Deliverable**:
Night sky with subtly animated stars and nebula clouds that enhance atmosphere without distraction.

**Verification**:
- Run `npm run dev`
- Visual inspection in browser:
  - [ ] Stars/nebulae visible and subtly animated (twinkling, slow movement)
  - [ ] Background gradient smooth and atmospheric
  - [ ] Responsive on resize (use browser dev tools to test different screen sizes)
  - [ ] Stars don't distract from main content area

---

### [x] Step: Phase 3 - Pre-existing Hovering Lanterns

**Task Definition**:
Implement 5-7 pre-existing lanterns with wholesome words that gently hover in the upper half of the screen with warm glow effects and physics-based animation.

**Contracts to Implement**:
- Data Model: **Hovering Lantern Object** `{ id, text, x, y, opacity }`
- CSS Module classes: `.lantern`, `.hoveringLantern`, `.lanternText`
- Animation Config: **Hovering Lantern Spring Config**

**Tasks**:
1. In `SkyLanternApp.jsx`, create initial state with 5-7 hovering lantern objects:
   - Default words: "Hope", "Joy", "Health", "Love", "Peace", "Dream", "Unity"
   - Random x positions (within safe bounds: 10% - 90% of screen width)
   - Random y positions (upper half: 10% - 50% of screen height)
2. Implement lantern bloom/glow CSS in `.module.css`:
   - Base `.lantern` class: rectangular container, rounded corners, warm colors
   - Layered `box-shadow` with warm colors (oranges, golds) and high blur radii
   - `filter: drop-shadow()` for outer glow
   - `.lanternText` with `filter: brightness()` for glowing text effect
3. Use react-spring `useSpring` with `loop: true` for each hovering lantern:
   - Create gentle bobbing (up/down 20-30px range)
   - Add subtle swaying (left/right 10-15px range)
   - Config: `{ mass: 2, tension: 20, friction: 30 }`
4. Implement fade-out logic with `useEffect` timer:
   - After 30-60 seconds, gradually reduce opacity to 0
   - Remove from state when fully faded
5. Ensure lanterns never leave viewport bounds during animation

**Deliverable**:
5-7 warmly glowing lanterns hovering in the upper sky with gentle physics-based animation that slowly fade out over time.

**Verification**:
- Run `npm run dev`
- Visual and behavioral checks:
  - [ ] 5-7 lanterns appear on load in upper half of screen
  - [ ] Lanterns have visible warm glow (orange/gold halo effect)
  - [ ] Lanterns bob and sway smoothly without jerky motion
  - [ ] Wait 30-60 seconds → lanterns slowly fade out and disappear
  - [ ] No lanterns leave viewport bounds during hover animation
  - [ ] Text inside lanterns is clearly readable with glow effect

---

### [x] Step: Phase 4 - Glassmorphism Input Interface

**Task Definition**:
Create a modern glassmorphism-styled input interface at the bottom center of the screen with a text field and send button.

**Contracts to Implement**:
- CSS Module classes: `.inputContainer`, `.input`, `.sendButton`
- React state: `inputValue` (string)
- Event handlers: `handleInputChange`, `handleSubmit`

**Tasks**:
1. In `SkyLanternApp.jsx`, add state for input value: `const [inputValue, setInputValue] = useState('')`
2. Create input container JSX at bottom center of screen
3. In `SkyLanternApp.module.css`, implement glassmorphism:
   - `.inputContainer`: positioned at bottom center (fixed or absolute)
   - `backdrop-filter: blur(10px)` for frosted glass effect
   - Translucent white background: `rgba(255, 255, 255, 0.1)`
   - Subtle border: `1px solid rgba(255, 255, 255, 0.2)`
   - Proper padding and border-radius
4. Style `.input` field: transparent background, white text, placeholder styling
5. Style `.sendButton`: subtle hover effect, icon or text "Send"
6. Implement `handleSubmit` function:
   - Prevent default form submission
   - Log input value (for now)
   - Clear input field: `setInputValue('')`
7. Handle Enter key press on input field
8. Add responsive styles for mobile (ensure keyboard doesn't obscure input)

**Deliverable**:
Functional glassmorphism input field at bottom center that accepts text input and clears on submit.

**Verification**:
- Run `npm run dev`
- Test interactions:
  - [ ] Input visible at bottom center of screen
  - [ ] Glassmorphism effect visible (frosted blur over background)
  - [ ] Type text in input field
  - [ ] Press Enter → input clears and value is logged to console
  - [ ] Click Send button → input clears and value is logged to console
  - [ ] On mobile (use DevTools responsive mode): input is accessible and keyboard doesn't hide it

---

### [x] Step: Phase 5 - User-Submitted Lantern Creation & Float Animation

**Task Definition**:
Implement the core feature: when user submits a wish, create a glowing lantern with the text that floats upward from bottom to top with physics-based wobble animation.

**Contracts to Implement**:
- Data Model: **Lantern Object** `{ id, text, createdAt, x, y }`
- React state: `floatingLanterns` (array, max 20)
- CSS Module class: `.floatingLantern`
- Animation Config: **Floating Lantern Spring Config**
- Function: `calculateFontSize(text)` for dynamic text sizing

**Tasks**:
1. Add state for floating lanterns: `const [floatingLanterns, setFloatingLanterns] = useState([])`
2. Update `handleSubmit` to create new lantern object:
   - Generate unique id: `Date.now() + Math.random()`
   - Get screen center x position: `window.innerWidth / 2`
   - Set initial y position: `window.innerHeight - 200`
   - Create lantern object and add to state
   - Enforce max 20 lanterns (remove oldest if exceeded)
3. Implement `calculateFontSize(text)` utility:
   - Base calculation on text length
   - Return font size between 12px - 32px
   - Longer text → smaller font
4. Use react-spring `useTransition` to manage floating lanterns:
   - `from`: bottom center position, opacity 1
   - `to`: top of screen (y: -200), opacity 0
   - `config`: `{ mass: 1, tension: 20, friction: 10 }`
   - Add wobble: animate x position with oscillation during ascent
5. Apply dynamic font size to lantern text as inline style
6. Use `onRest` callback to remove lantern from state when animation completes
7. Style `.floatingLantern` with same glow effects as hovering lanterns

**Deliverable**:
Functional wish submission that creates a glowing lantern at the bottom which floats upward with wobble animation and auto-sized text.

**Verification**:
- Run `npm run dev`
- Test submission flow:
  - [ ] Type wish in input, submit → lantern appears at bottom center with text visible
  - [ ] Lantern displays text clearly with warm glow effect
  - [ ] Lantern floats upward with gentle left-right wobble (not straight line)
  - [ ] Try short word (e.g., "Joy") → text is large and readable
  - [ ] Try long phrase (e.g., "May all my dreams come true") → text auto-sizes to fit lantern
  - [ ] Lantern disappears when it reaches top of screen
  - [ ] Submit 25 lanterns rapidly → verify only 20 active at once (oldest removed)

---

### [x] Step: Phase 6 - Wishes List Sidebar

**Task Definition**:
Create a sidebar that displays all submitted wishes after they float off screen, accessible on both mobile and desktop.

**Contracts to Implement**:
- Data Model: **Wish Object** `{ id, text, timestamp }`
- React state: `wishes` (array)
- CSS Module classes: `.sidebar`, `.wishItem`

**Tasks**:
1. Add state for wishes: `const [wishes, setWishes] = useState([])`
2. Update `useTransition` `onRest` callback in Phase 5:
   - When lantern animation completes, add wish to wishes array
   - Create wish object: `{ id: lantern.id, text: lantern.text, timestamp: Date.now() }`
3. Create sidebar JSX section:
   - Display wishes in reverse chronological order (newest first)
   - Show wish text and optionally timestamp
4. Style `.sidebar` in CSS Module:
   - Fixed position on right side (desktop)
   - Semi-transparent background: `rgba(0, 0, 0, 0.3)`
   - Backdrop blur for consistency
   - Scrollable if many wishes
5. Style `.wishItem`: proper padding, spacing, subtle border
6. Add responsive behavior for mobile:
   - Option 1: Collapsible sidebar (toggle button)
   - Option 2: Bottom sheet or slide-in drawer
   - Ensure sidebar doesn't obstruct main lantern view
7. Add subtle animations for new wish items appearing in list

**Deliverable**:
Functional wishes list sidebar that archives all submitted wishes after they float off screen, responsive on all devices.

**Verification**:
- Run `npm run dev`
- Test sidebar functionality:
  - [ ] Submit multiple wishes (e.g., 5 wishes)
  - [ ] After each lantern floats off screen, verify wish appears in sidebar
  - [ ] Wishes appear in chronological order (newest first or oldest first, as designed)
  - [ ] Sidebar doesn't block main view or interfere with lantern animations
  - [ ] On mobile (DevTools responsive mode): sidebar is accessible via toggle or always visible
  - [ ] Sidebar is scrollable if many wishes are added
  - [ ] Wishes list persists during entire session

---

### [x] Step: Phase 7 - Polish, Performance & Cross-Device Testing

**Task Definition**:
Final optimization pass including performance tuning, visual polish, and comprehensive cross-device/browser testing.

**Contracts to Implement**:
- Helper Script: `test-performance.html` (from spec)
- Final CSS optimizations

**Tasks**:
1. Create `test-performance.html` in project root (per spec template):
   - Add FPS counter overlay
   - Use Performance API to measure frame rate
2. Optimize CSS for GPU acceleration:
   - Add `will-change: transform` to animated lantern classes
   - Ensure animations use `transform` and `opacity` only (not layout properties)
3. Fine-tune visual aesthetics:
   - Adjust glow intensity, blur radii, colors for optimal warm effect
   - Tweak spring physics configs (mass, tension, friction) for desired feel
   - Ensure text readability across all scenarios
4. Add micro-interactions:
   - Hover effect on send button
   - Focus states on input field
   - Subtle transitions on sidebar items
5. Cross-browser testing:
   - Test in Chrome, Firefox, Safari, Edge
   - Verify backdrop-filter support (fallback if needed)
   - Check CSS compatibility
6. Cross-device responsive testing:
   - Mobile: 375px (iPhone SE), 360px (Android)
   - Tablet: 768px (iPad), 820px (iPad Air)
   - Desktop: 1920px, 2560px
7. Performance testing:
   - Submit 20 lanterns
   - Use `test-performance.html` to verify 60fps
   - Profile with Chrome DevTools Performance tab
8. Final UX review: ensure experience evokes calm, hope, warmth

**Deliverable**:
Production-ready app optimized for performance, fully responsive, and cross-browser compatible with polished visual aesthetics.

**Verification**:
- Run `npm run build` to create production build
- Run `npm run preview` to test production build
- Performance checks:
  - [ ] Open `test-performance.html` in browser
  - [ ] Submit 20 lanterns
  - [ ] Verify FPS counter shows ~60fps consistently
  - [ ] Open Chrome DevTools Performance tab, record, verify 60fps timeline
- Cross-browser testing:
  - [ ] Test in Chrome → all features work, glow effects render correctly
  - [ ] Test in Firefox → all features work, glow effects render correctly
  - [ ] Test in Safari → all features work, backdrop-filter supported
  - [ ] Test in Edge → all features work
- Responsive testing (use DevTools):
  - [ ] 375px width (mobile) → layout adapts, all features accessible
  - [ ] 768px width (tablet) → layout adapts, sidebar positioned appropriately
  - [ ] 1920px width (desktop) → layout uses space well, sidebar visible
  - [ ] Resize window dynamically → layout adapts smoothly without breaking
- Visual polish:
  - [ ] Lantern glow effects are warm, soft, and atmospheric
  - [ ] Glassmorphism input looks like frosted glass
  - [ ] Text is readable in all lanterns
  - [ ] Overall aesthetic feels calm, hopeful, and warm
- Final checks:
  - [ ] No console errors or warnings
  - [ ] All interactions work smoothly
  - [ ] App feels polished and ready for production
